Context fallback file
Generated: 2025-11-05T18:13:35.818Z

# TREE (approx)
/
.github/scripts/
.github/workflows/
scripts/

# FILES

// ---- FILE: .github/scripts/fallback-generate-context.js ----
/* eslint-disable no-console */
"use strict";

// Fallback-генератор .meta, не требует внешних зависимостей.
// Запуск: node .github/scripts/fallback-generate-context.js

const fs = require("fs");
const path = require("path");

const ROOT = process.env.GITHUB_WORKSPACE || process.cwd();
const META = path.join(ROOT, ".meta");

if (!fs.existsSync(META)) fs.mkdirSync(META, { recursive: true });

const BLOCK_DIRS = new Set([
  "node_modules", ".git", ".next", "dist", "build", "out", "coverage",
  ".meta", ".vscode", ".idea", ".cache", ".husky"
]);
const ALLOW_DOT_DIRS = new Set([".github"]); // .github оставляем
const TEXT_EXTS = new Set([
  ".ts",".tsx",".js",".jsx",".json",".yaml",".yml",".md",".css",".scss",".less",
  ".txt",".html",".webmanifest",".env",".env.example",".yml"
]);

const toUnix = (p) => p.replace(/\\/g, "/");

function shouldSkip(rel, name, isDir) {
  const u = toUnix(rel);
  // Явные системные каталоги в любом месте пути
  for (const b of BLOCK_DIRS) {
    if (u === b || u.startsWith(`${b}/`) || u.includes(`/${b}/`)) return true;
  }
  if (isDir) {
    // Любая скрытая папка, кроме whitelisted (.github)
    if (name.startsWith(".") && !ALLOW_DOT_DIRS.has(name)) return true;
  }
  return false;
}

function isText(file) {
  const low = file.toLowerCase();
  for (const ext of TEXT_EXTS) if (low.endsWith(ext)) return true;
  return false;
}

function listFiles() {
  const res = [];
  const stack = [ROOT];
  while (stack.length) {
    const d = stack.pop();
    let ents = [];
    try {
      ents = fs.readdirSync(d, { withFileTypes: true });
    } catch {
      continue;
    }
    for (const it of ents) {
      const full = path.join(d, it.name);
      const rel = toUnix(path.relative(ROOT, full)) || ".";
      if (shouldSkip(rel, it.name, it.isDirectory())) continue;
      try {
        if (it.isDirectory()) stack.push(full);
        else if (it.isFile()) res.push(rel);
      } catch {}
    }
  }
  return res.sort();
}

function generate() {
  const files = listFiles();

  // Простое «дерево» из уникальных директорий
  const dirSet = new Set(files.map((f) => toUnix(path.dirname(f))));
  const treeLines = Array.from(dirSet)
    .sort()
    .map((d) => (d === "." ? "/" : d + "/"));

  // FULL
  let full = `Context fallback file
Generated: ${new Date().toISOString()}

# TREE (approx)
${treeLines.join("\n")}

# FILES
`;

  for (const f of files) {
    const p = path.join(ROOT, f);
    let body = "";
    if (isText(f)) {
      try {
        body = fs.readFileSync(p, "utf8");
      } catch (e) {
        body = `// read error: ${e.message}`;
      }
    } else {
      try {
        const st = fs.statSync(p);
        body = `// binary or non-text file (${Math.round(st.size / 1024)} KB)`;
      } catch {
        body = "// unknown file";
      }
    }
    full += `\n// ---- FILE: ${f} ----\n${body}\n`;
  }

  fs.writeFileSync(path.join(META, "project-full.txt"), full, "utf8");

  // ADAPTIVE
  let adaptive = "# COMPACT STRUCTURE\n";
  const dirMap = new Map();
  for (const f of files) {
    const d = toUnix(path.dirname(f));
    const b = path.basename(f);
    if (!dirMap.has(d)) dirMap.set(d, []);
    dirMap.get(d).push(b);
  }
  for (const d of Array.from(dirMap.keys()).sort()) {
    adaptive += (d === "." ? "/" : d + "/") + " " + dirMap.get(d).sort().join(", ") + "\n";
  }
  fs.writeFileSync(path.join(META, "project-adaptive.txt"), adaptive, "utf8");

  console.log("Fallback generation done.");
}

try {
  generate();
} catch (e) {
  console.error("Fallback error:", e);
  process.exit(1);
}


// ---- FILE: .github/workflows/auto-sync.yml ----
name: Auto Sync .meta to meta branch

on:
  schedule:
    - cron: "0 */6 * * *"
  workflow_dispatch: {}

permissions:
  contents: write

concurrency:
  group: "meta-sync"
  cancel-in-progress: true

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Run repo generator (continue on error)
        id: repo_gen
        continue-on-error: true
        run: |
          mkdir -p .meta
          if [ -f scripts/generate-context.js ]; then
            node scripts/generate-context.js --mode=both --max-lines=20000
          else
            echo "scripts/generate-context.js not found"
            exit 2
          fi

      - name: Run fallback generator (node file)
        if: steps.repo_gen.outcome != 'success'
        run: |
          node .github/scripts/fallback-generate-context.js

      - name: Publish .meta to 'meta' branch
        run: |
          set -e
          BRANCH=meta
          git fetch origin $BRANCH || true
          if git show-ref --quiet refs/heads/$BRANCH; then
            echo "Branch $BRANCH exists"
          else
            git branch $BRANCH || true
          fi
          git worktree add _meta_worktree $BRANCH || true
          rsync -a --delete .meta/ _meta_worktree/
          cd _meta_worktree
          if [ -n "$(git status --porcelain)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "chore(meta): refresh context"
            git push origin $BRANCH || echo "Push failed — check branch protections"
          else
            echo "No changes for meta branch"
          fi


// ---- FILE: .github/workflows/generate-context.yml ----
name: Generate Context (.meta)

on:
  push:
    branches: [ main ]
    paths-ignore:
      - ".meta/**"
  pull_request:
    branches: [ main ]
    paths-ignore:
      - ".meta/**"
  workflow_dispatch: {}

permissions:
  contents: write

concurrency:
  group: "generate-context-${{ github.ref_name }}"
  cancel-in-progress: true

jobs:
  generate:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Run repo generator (continue on error)
        id: repo_gen
        continue-on-error: true
        run: |
          mkdir -p .meta
          if [ -f scripts/generate-context.js ]; then
            node scripts/generate-context.js --mode=both --max-lines=20000
          else
            echo "scripts/generate-context.js not found"
            exit 2
          fi

      - name: Run fallback generator (node file)
        if: steps.repo_gen.outcome != 'success'
        run: |
          node .github/scripts/fallback-generate-context.js

      - name: Commit .meta on push to main
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          if [ -n "$(git status --porcelain .meta)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add .meta
            git commit -m "chore(meta): update project context"
            git push || echo "Push failed (branch may be protected)"
          else
            echo "No changes in .meta"
          fi

      - name: Upload .meta as artifact on PR
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: meta-files
          path: .meta/


// ---- FILE: .mccontextignore ----
// binary or non-text file (0 KB)

// ---- FILE: package.json ----
{
  "name": "music-connections",
  "version": "0.1.0",
  "private": true,
  "description": "Музыкальные связи — PWA (Next.js). Данные YAML/JSON. Таймлайн, граф, карта. RU/EN/ORIG.",
  "scripts": {
    "generate:context": "node scripts/generate-context.js --mode=both --max-lines=20000",
    "generate:context:full": "node scripts/generate-context.js --mode=full",
    "generate:context:adaptive": "node scripts/generate-context.js --mode=adaptive --max-lines=20000"
  },
  "engines": {
    "node": ">=16.14"
  },
  "license": "MIT"
}


// ---- FILE: scripts/generate-context.js. ----
// binary or non-text file (18 KB)
