name: Auto Sync .meta to meta branch

on:
  schedule:
    - cron: "0 */6 * * *"
  workflow_dispatch: {}

permissions:
  contents: write

concurrency:
  group: "meta-sync"
  cancel-in-progress: true

jobs:
  sync:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Run repo generator (continue on error)
        id: repo_gen
        continue-on-error: true
        run: |
          mkdir -p .meta
          if [ -f scripts/generate-context.js ]; then
            node scripts/generate-context.js --mode=both --max-lines=20000
          else
            echo "scripts/generate-context.js not found"
            exit 2
          fi

      - name: Fallback generator (actions/github-script)
        if: steps.repo_gen.outcome != 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const ROOT = process.env.GITHUB_WORKSPACE || process.cwd();
            const META = path.join(ROOT, '.meta');
            if (!fs.existsSync(META)) fs.mkdirSync(META, { recursive: true });

            const excludeHints = ['node_modules','/.git/','/.next/','/dist/','/build/','/out/','/coverage/','/.meta/'];
            const textExts = ['.ts','.tsx','.js','.jsx','.json','.yaml','.yml','.md','.css','.scss','.less','.txt','.html','.webmanifest','.env','.env.example'];
            const toUnix = p => p.replace(/\\/g, '/');
            const isText = f => textExts.some(e => f.toLowerCase().endsWith(e));
            const listFiles = () => {
              const res=[]; const stack=[ROOT];
              while (stack.length) {
                const d = stack.pop();
                let ents=[]; try { ents = fs.readdirSync(d, { withFileTypes: true }); } catch { continue; }
                for (const it of ents) {
                  const full = path.join(d, it.name);
                  const rel = toUnix(path.relative(ROOT, full)) || '.';
                  if (excludeHints.some(x => rel.includes(toUnix(x)))) continue;
                  try { if (it.isDirectory()) stack.push(full); else if (it.isFile()) res.push(rel); } catch {}
                }
              }
              return res.sort();
            };

            const files = listFiles();
            let full = `Context fallback
            Generated: ${new Date().toISOString()}\n`;
            for (const f of files) {
              const p = path.join(ROOT, f);
              let body = '';
              if (isText(f)) {
                try { body = fs.readFileSync(p, 'utf8'); } catch (e) { body = `// read error: ${e.message}`; }
              } else {
                body = '// non-text';
              }
              full += `\n// FILE: ${f}\n${body}\n`;
            }
            if (!fs.existsSync(META)) fs.mkdirSync(META, { recursive: true });
            fs.writeFileSync(path.join(META, 'project-full.txt'), full, 'utf8');

            let adaptive = "# COMPACT STRUCTURE\n";
            const dirMap = new Map();
            for (const f of files) {
              const d = toUnix(path.dirname(f));
              const b = path.basename(f);
              if (!dirMap.has(d)) dirMap.set(d, []);
              dirMap.get(d).push(b);
            }
            for (const d of Array.from(dirMap.keys()).sort()) {
              adaptive += (d==='.'?'/':d+'/') + ' ' + dirMap.get(d).sort().join(', ') + "\n";
            }
            fs.writeFileSync(path.join(META, 'project-adaptive.txt'), adaptive, 'utf8');

      - name: Publish .meta to 'meta' branch
        run: |
          set -e
          BRANCH=meta
          git fetch origin $BRANCH || true
          if git show-ref --quiet refs/heads/$BRANCH; then
            echo "Branch $BRANCH exists"
          else
            git branch $BRANCH || true
          fi
          git worktree add _meta_worktree $BRANCH || true
          rsync -a --delete .meta/ _meta_worktree/
          cd _meta_worktree
          if [ -n "$(git status --porcelain)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "chore(meta): refresh context"
            git push origin $BRANCH || echo "Push failed â€” check branch protections"
          else
            echo "No changes for meta branch"
          fi
