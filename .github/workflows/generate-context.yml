name: Generate Context (.meta)

on:
  push:
    branches: [ main ]
    paths-ignore:
      - ".meta/**"
  pull_request:
    branches: [ main ]
    paths-ignore:
      - ".meta/**"
  workflow_dispatch: {}

permissions:
  contents: write

concurrency:
  group: "generate-context-${{ github.ref_name }}"
  cancel-in-progress: true

jobs:
  generate:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Run repo generator (continue on error)
        id: repo_gen
        continue-on-error: true
        run: |
          mkdir -p .meta
          if [ -f scripts/generate-context.js ]; then
            node scripts/generate-context.js --mode=both --max-lines=20000
          else
            echo "scripts/generate-context.js not found"
            exit 2
          fi

      - name: Fallback generator (actions/github-script)
        if: steps.repo_gen.outcome != 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const ROOT = process.env.GITHUB_WORKSPACE || process.cwd();
            const META = path.join(ROOT, '.meta');
            if (!fs.existsSync(META)) fs.mkdirSync(META, { recursive: true });

            const excludeHints = ['node_modules','/.git/','/.next/','/dist/','/build/','/out/','/coverage/','/.meta/','.vscode','.idea'];
            const textExts = ['.ts','.tsx','.js','.jsx','.json','.yaml','.yml','.md','.css','.scss','.less','.txt','.html','.webmanifest','.env','.env.example'];
            const toUnix = p => p.replace(/\\/g, '/');
            const isText = f => textExts.some(e => f.toLowerCase().endsWith(e));
            const listFiles = () => {
              const res=[]; const stack=[ROOT];
              while (stack.length) {
                const d = stack.pop();
                let ents=[]; try { ents = fs.readdirSync(d, { withFileTypes: true }); } catch { continue; }
                for (const it of ents) {
                  const full = path.join(d, it.name);
                  const rel = toUnix(path.relative(ROOT, full)) || '.';
                  if (excludeHints.some(x => rel.includes(toUnix(x)))) continue;
                  try {
                    if (it.isDirectory()) stack.push(full);
                    else if (it.isFile()) res.push(rel);
                  } catch {}
                }
              }
              return res.sort();
            };

            // FULL
            const files = listFiles();
            let full = `Context fallback file
            Generated: ${new Date().toISOString()}

            # TREE (approx)
            `;
            // simple tree
            const dirs = new Set(files.map(f => toUnix(path.dirname(f))));
            const treeLines = Array.from(dirs).sort().map(d => (d === '.' ? '/' : d + '/'));
            full += treeLines.join('\n') + '\n\n# FILES\n';
            for (const f of files) {
              const p = path.join(ROOT, f);
              let body = '';
              if (isText(f)) {
                try { body = fs.readFileSync(p, 'utf8'); } catch (e) { body = `// read error: ${e.message}`; }
              } else {
                try { const st = fs.statSync(p); body = `// binary or non-text file (${Math.round(st.size/1024)} KB)`; }
                catch { body = '// unknown file'; }
              }
              full += `\n// ---- FILE: ${f} ----\n` + body + '\n';
            }
            fs.writeFileSync(path.join(META, 'project-full.txt'), full, 'utf8');

            // ADAPTIVE
            let adaptive = '# COMPACT STRUCTURE\n';
            const dirMap = new Map();
            for (const f of files) {
              const d = toUnix(path.dirname(f));
              const b = path.basename(f);
              if (!dirMap.has(d)) dirMap.set(d, []);
              dirMap.get(d).push(b);
            }
            for (const d of Array.from(dirMap.keys()).sort()) {
              adaptive += (d === '.' ? '/' : d + '/') + ' ' + dirMap.get(d).sort().join(', ') + '\n';
            }
            fs.writeFileSync(path.join(META, 'project-adaptive.txt'), adaptive, 'utf8');

            core.info('Fallback generation done.');

      - name: Commit .meta on push to main
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          if [ -n "$(git status --porcelain .meta)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add .meta
            git commit -m "chore(meta): update project context"
            git push || echo "Push failed (branch may be protected)"
          else
            echo "No changes in .meta"
          fi

      - name: Upload .meta as artifact on PR
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: meta-files
          path: .meta/
