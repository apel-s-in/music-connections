name: Generate Context (.meta)

on:
  push:
    branches: [ main ]
    paths-ignore:
      - ".meta/**"
  pull_request:
    branches: [ main ]
    paths-ignore:
      - ".meta/**"
  workflow_dispatch: {}

permissions:
  contents: write

concurrency:
  group: "generate-context-${{ github.ref_name }}"
  cancel-in-progress: true

jobs:
  generate:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Run repo generator (continue on error)
        id: repo_gen
        continue-on-error: true
        run: |
          mkdir -p .meta
          if [ -f scripts/generate-context.js ]; then
            node scripts/generate-context.js --mode=both --max-lines=20000
          else
            echo "scripts/generate-context.js not found"
            exit 2
          fi

      - name: Fallback generator (actions/github-script)
        if: steps.repo_gen.outcome != 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const ROOT = process.env.GITHUB_WORKSPACE || process.cwd();
            const META = path.join(ROOT, '.meta');
            if (!fs.existsSync(META)) fs.mkdirSync(META, { recursive: true });

            const BLOCK_DIRS = new Set([
              'node_modules','.git','.next','dist','build','out','coverage','.meta',
              '.vscode','.idea','.cache','.husky'
            ]);
            const ALLOW_DOT_DIRS = new Set(['.github']); // .github оставляем
            const TEXT_EXTS = new Set([
              '.ts','.tsx','.js','.jsx','.json','.yaml','.yml','.md','.css','.scss','.less',
              '.txt','.html','.webmanifest','.env','.env.example','.yml'
            ]);
            const toUnix = p => p.replace(/\\/g, '/');

            function shouldSkip(rel, name, isDir) {
              const u = toUnix(rel);
              // Явные системные каталоги в любом месте пути
              for (const b of BLOCK_DIRS) {
                if (u === b || u.startsWith(`${b}/`) || u.includes(`/${b}/`)) return true;
              }
              if (isDir) {
                // Любая скрытая папка, кроме whitelisted (.github)
                if (name.startsWith('.') && !ALLOW_DOT_DIRS.has(name)) return true;
              }
              return false;
            }

            function isText(file) {
              const low = file.toLowerCase();
              for (const ext of TEXT_EXTS) if (low.endsWith(ext)) return true;
              return false;
            }

            function listFiles() {
              const res = [];
              const stack = [ROOT];
              while (stack.length) {
                const d = stack.pop();
                let ents = [];
                try { ents = fs.readdirSync(d, { withFileTypes: true }); } catch { continue; }
                for (const it of ents) {
                  const full = path.join(d, it.name);
                  const rel = toUnix(path.relative(ROOT, full)) || '.';
                  const skip = shouldSkip(rel, it.name, it.isDirectory());
                  if (skip) continue;
                  try {
                    if (it.isDirectory()) stack.push(full);
                    else if (it.isFile()) res.push(rel);
                  } catch {}
                }
              }
              return res.sort();
            }

            // FULL
            const files = listFiles();

            // Простейшее дерево из уникальных директорий
            const dirSet = new Set(files.map(f => toUnix(path.dirname(f))));
            const treeLines = Array.from(dirSet).sort().map(d => (d === '.' ? '/' : d + '/'));

            let full = `Context fallback file
Generated: ${new Date().toISOString()}

# TREE (approx)
${treeLines.join('\n')}

# FILES
`;

            for (const f of files) {
              const p = path.join(ROOT, f);
              let body = '';
              if (isText(f)) {
                try { body = fs.readFileSync(p, 'utf8'); } catch (e) { body = `// read error: ${e.message}`; }
              } else {
                try { const st = fs.statSync(p); body = `// binary or non-text file (${Math.round(st.size/1024)} KB)`; }
                catch { body = '// unknown file'; }
              }
              full += `\n// ---- FILE: ${f} ----\n` + body + '\n';
            }
            fs.writeFileSync(path.join(META, 'project-full.txt'), full, 'utf8');

            // ADAPTIVE
            let adaptive = '# COMPACT STRUCTURE\n';
            const dirMap = new Map();
            for (const f of files) {
              const d = toUnix(path.dirname(f));
              const b = path.basename(f);
              if (!dirMap.has(d)) dirMap.set(d, []);
              dirMap.get(d).push(b);
            }
            for (const d of Array.from(dirMap.keys()).sort()) {
              adaptive += (d === '.' ? '/' : d + '/') + ' ' + dirMap.get(d).sort().join(', ') + '\n';
            }
            fs.writeFileSync(path.join(META, 'project-adaptive.txt'), adaptive, 'utf8');

            core.info('Fallback generation done (with .git excluded).');

      - name: Commit .meta on push to main
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          if [ -n "$(git status --porcelain .meta)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add .meta
            git commit -m "chore(meta): update project context"
            git push || echo "Push failed (branch may be protected)"
          else
            echo "No changes in .meta"
          fi

      - name: Upload .meta as artifact on PR
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: meta-files
          path: .meta/
